var RoughNotation = function (t) { "use strict"; let e = "http://www.w3.org/2000/svg"; class s { constructor(t) { this.seed = t } next() { return this.seed ? (2147483648 - 1 & (this.seed = Math.imul(48271, this.seed))) / 2147483648 : Math.random() } } function i(t, e, s, i, n) { return { type: "path", ops: c(t, e, s, i, n) } } function n(t, e, s) { let n = (t || []).length; if (n > 2) { let r = []; for (let o = 0; o < n - 1; o++)r.push(...c(t[o][0], t[o][1], t[o + 1][0], t[o + 1][1], s)); return e && r.push(...c(t[n - 1][0], t[n - 1][1], t[0][0], t[0][1], s)), { type: "path", ops: r } } return 2 === n ? i(t[0][0], t[0][1], t[1][0], t[1][1], s) : { type: "path", ops: [] } } function r(t, e, s, i, r) { var o, a; return o = [[t, e], [t + s, e], [t + s, e + i], [t, e + i]], n(o, !0, a = r) } function o(t, e, s, i, n) { return function (t, e, s, i) { let [n, r] = g(i.increment, t, e, i.rx, i.ry, 1, i.increment * h(.1, h(.4, 1, s), s), s), o = f(n, null, s); if (!s.disableMultiStroke) { let [a] = g(i.increment, t, e, i.rx, i.ry, 1.5, 0, s), l = f(a, null, s); o = o.concat(l) } return { estimatedPoints: r, opset: { type: "path", ops: o } } }(t, e, n, function (t, e, s) { let i = Math.max(s.curveStepCount, s.curveStepCount / Math.sqrt(200) * Math.sqrt(2 * Math.PI * Math.sqrt((Math.pow(t / 2, 2) + Math.pow(e / 2, 2)) / 2))), n = Math.abs(t / 2), r = Math.abs(e / 2), o = 1 - s.curveFitting; return n += l(n * o, s), r += l(r * o, s), { increment: 2 * Math.PI / i, rx: n, ry: r } }(s, i, n)).opset } function a(t) { return t.randomizer || (t.randomizer = new s(t.seed || 0)), t.randomizer.next() } function h(t, e, s, i = 1) { return s.roughness * i * (a(s) * (e - t) + t) } function l(t, e, s = 1) { return h(-t, t, e, s) } function c(t, e, s, i, n, r = !1) { let o = r ? n.disableMultiStrokeFill : n.disableMultiStroke, a = u(t, e, s, i, n, !0, !1); if (o) return a; let h = u(t, e, s, i, n, !0, !0); return a.concat(h) } function u(t, e, s, i, n, r, o) { let h = Math.pow(t - s, 2) + Math.pow(e - i, 2), c = Math.sqrt(h), u = 1; u = c < 200 ? 1 : c > 500 ? .4 : -.0016668 * c + 1.233334; let f = n.maxRandomnessOffset || 0; f * f * 100 > h && (f = c / 10); let g = f / 2, d = .2 + .2 * a(n), p = n.bowing * n.maxRandomnessOffset * (i - e) / 200, $ = n.bowing * n.maxRandomnessOffset * (t - s) / 200; p = l(p, n, u), $ = l($, n, u); let _ = [], m = () => l(g, n, u), b = () => l(f, n, u); return r && (o ? _.push({ op: "move", data: [t + m(), e + m()] }) : _.push({ op: "move", data: [t + l(f, n, u), e + l(f, n, u)] })), o ? _.push({ op: "bcurveTo", data: [p + t + (s - t) * d + m(), $ + e + (i - e) * d + m(), p + t + 2 * (s - t) * d + m(), $ + e + 2 * (i - e) * d + m(), s + m(), i + m()] }) : _.push({ op: "bcurveTo", data: [p + t + (s - t) * d + b(), $ + e + (i - e) * d + b(), p + t + 2 * (s - t) * d + b(), $ + e + 2 * (i - e) * d + b(), s + b(), i + b()] }), _ } function f(t, e, s) { let i = t.length, n = []; if (i > 3) { let r = [], o = 1 - s.curveTightness; n.push({ op: "move", data: [t[1][0], t[1][1]] }); for (let a = 1; a + 2 < i; a++) { let h = t[a]; r[0] = [h[0], h[1]], r[1] = [h[0] + (o * t[a + 1][0] - o * t[a - 1][0]) / 6, h[1] + (o * t[a + 1][1] - o * t[a - 1][1]) / 6], r[2] = [t[a + 1][0] + (o * t[a][0] - o * t[a + 2][0]) / 6, t[a + 1][1] + (o * t[a][1] - o * t[a + 2][1]) / 6], r[3] = [t[a + 1][0], t[a + 1][1]], n.push({ op: "bcurveTo", data: [r[1][0], r[1][1], r[2][0], r[2][1], r[3][0], r[3][1]] }) } if (e && 2 === e.length) { let u = s.maxRandomnessOffset; n.push({ op: "lineTo", data: [e[0] + l(u, s), e[1] + l(u, s)] }) } } else 3 === i ? (n.push({ op: "move", data: [t[1][0], t[1][1]] }), n.push({ op: "bcurveTo", data: [t[1][0], t[1][1], t[2][0], t[2][1], t[2][0], t[2][1]] })) : 2 === i && n.push(...c(t[0][0], t[0][1], t[1][0], t[1][1], s)); return n } function g(t, e, s, i, n, r, o, a) { let h = [], c = [], u = l(.5, a) - Math.PI / 2; c.push([l(r, a) + e + .9 * i * Math.cos(u - t), l(r, a) + s + .9 * n * Math.sin(u - t)]); for (let f = u; f < 2 * Math.PI + u - .01; f += t) { let g = [l(r, a) + e + i * Math.cos(f), l(r, a) + s + n * Math.sin(f)]; h.push(g), c.push(g) } return c.push([l(r, a) + e + i * Math.cos(u + 2 * Math.PI + .5 * o), l(r, a) + s + n * Math.sin(u + 2 * Math.PI + .5 * o)]), c.push([l(r, a) + e + .98 * i * Math.cos(u + o), l(r, a) + s + .98 * n * Math.sin(u + o)]), c.push([l(r, a) + e + .9 * i * Math.cos(u + .5 * o), l(r, a) + s + .9 * n * Math.sin(u + .5 * o)]), [c, h] } function d(t, e) { return { maxRandomnessOffset: 2, roughness: "highlight" === t ? 3 : 1.5, bowing: 1, stroke: "#000", strokeWidth: 1.5, curveTightness: 0, curveFitting: .95, curveStepCount: 9, fillStyle: "hachure", fillWeight: -1, hachureAngle: -41, hachureGap: -1, dashOffset: -1, dashGap: -1, zigzagOffset: -1, combineNestedSvgPaths: !1, disableMultiStroke: "double" !== t, disableMultiStrokeFill: !1, seed: e } } function p(t, s, a, h, l, c) { let u = [], f = a.strokeWidth || 2, g = function (t) { let e = t.padding; if (e || 0 === e) { if ("number" == typeof e) return [e, e, e, e]; if (Array.isArray(e)) { let s = e; if (s.length) switch (s.length) { case 4: return [...s]; case 1: return [s[0], s[0], s[0], s[0]]; case 2: return [...s, ...s]; case 3: return [...s, s[1]]; default: return [s[0], s[1], s[2], s[3]] } } } return [5, 5, 5, 5] }(a), p = void 0 === a.animate || !!a.animate, $ = a.iterations || 2, _ = a.rtl ? 1 : 0, m = d("single", c); switch (a.type) { case "underline": { let b = s.y + s.h + g[2]; for (let v = _; v < $ + _; v++)v % 2 ? u.push(i(s.x + s.w, b, s.x, b, m)) : u.push(i(s.x, b, s.x + s.w, b, m)); break } case "strike-through": { let w = s.y + s.h / 2; for (let x = _; x < $ + _; x++)x % 2 ? u.push(i(s.x + s.w, w, s.x, w, m)) : u.push(i(s.x, w, s.x + s.w, w, m)); break } case "box": { let y = s.x - g[3], k = s.y - g[0], S = s.w + (g[1] + g[3]), R = s.h + (g[0] + g[2]); for (let z = 0; z < $; z++)u.push(r(y, k, S, R, m)); break } case "bracket": { let C = Array.isArray(a.brackets) ? a.brackets : a.brackets ? [a.brackets] : ["right"], D = s.x - 2 * g[3], L = s.x + s.w + 2 * g[1], N = s.y - 2 * g[0], E = s.y + s.h + 2 * g[2]; for (let T of C) { let O; switch (T) { case "bottom": O = [[D, s.y + s.h], [D, E], [L, E], [L, s.y + s.h]]; break; case "top": O = [[D, s.y], [D, N], [L, N], [L, s.y]]; break; case "left": O = [[s.x, N], [D, N], [D, E], [s.x, E]]; break; case "right": O = [[s.x + s.w, N], [L, N], [L, E], [s.x + s.w, E]] }O && u.push(n(O, !1, m)) } break } case "crossed-off": { let I = s.x, P = s.y, B = I + s.w, M = P + s.h; for (let W = _; W < $ + _; W++)W % 2 ? u.push(i(B, M, I, P, m)) : u.push(i(I, P, B, M, m)); for (let q = _; q < $ + _; q++)q % 2 ? u.push(i(I, M, B, P, m)) : u.push(i(B, P, I, M, m)); break } case "circle": { let A = d("double", c), F = s.w + (g[1] + g[3]), G = s.h + (g[0] + g[2]), j = s.x - g[3] + F / 2, H = s.y - g[0] + G / 2, J = Math.floor($ / 2), K = $ - 2 * J; for (let Q = 0; Q < J; Q++)u.push(o(j, H, F, G, A)); for (let U = 0; U < K; U++)u.push(o(j, H, F, G, m)); break } case "highlight": { let V = d("highlight", c); f = .95 * s.h; let X = s.y + s.h / 2; for (let Y = _; Y < $ + _; Y++)Y % 2 ? u.push(i(s.x + s.w, X, s.x, X, V)) : u.push(i(s.x, X, s.x + s.w, X, V)) } }if (u.length) { let Z = function (t) { let e = []; for (let s of t) { let i = ""; for (let n of s.ops) { let r = n.data; switch (n.op) { case "move": i.trim() && e.push(i.trim()), i = `M${r[0]} ${r[1]} `; break; case "bcurveTo": i += `C${r[0]} ${r[1]}, ${r[2]} ${r[3]}, ${r[4]} ${r[5]} `; break; case "lineTo": i += `L${r[0]} ${r[1]} ` } } i.trim() && e.push(i.trim()) } return e }(u), tt = [], te = [], ts = 0, ti = (t, e, s) => t.setAttribute(e, s); for (let tn of Z) { let tr = document.createElementNS(e, "path"); if (ti(tr, "d", tn), ti(tr, "fill", "none"), ti(tr, "stroke", a.color || "currentColor"), ti(tr, "stroke-width", "" + f), p) { let to = tr.getTotalLength(); tt.push(to), ts += to } t.appendChild(tr), te.push(tr) } if (p) { let ta = 0; for (let th = 0; th < te.length; th++) { let tl = te[th], tc = tt[th], tu = ts ? l * (tc / ts) : 0, tf = h + ta, tg = tl.style; tg.strokeDashoffset = "" + tc, tg.strokeDasharray = "" + tc, tg.animation = `rough-notation-dash ${tu}ms ease-out ${tf}ms forwards`, ta += tu } } } } class $ { constructor(t, e) { this._state = "unattached", this._resizing = !1, this._seed = Math.floor(2147483648 * Math.random()), this._lastSizes = [], this._animationDelay = 0, this._resizeListener = () => { this._resizing || (this._resizing = !0, setTimeout(() => { this._resizing = !1, "showing" === this._state && this.haveRectsChanged() && this.show() }, 400)) }, this._e = t, this._config = JSON.parse(JSON.stringify(e)), this.attach() } get animate() { return this._config.animate } set animate(t) { this._config.animate = t } get animationDuration() { return this._config.animationDuration } set animationDuration(t) { this._config.animationDuration = t } get iterations() { return this._config.iterations } set iterations(t) { this._config.iterations = t } get color() { return this._config.color } set color(t) { this._config.color !== t && (this._config.color = t, this.refresh()) } get strokeWidth() { return this._config.strokeWidth } set strokeWidth(t) { this._config.strokeWidth !== t && (this._config.strokeWidth = t, this.refresh()) } get padding() { return this._config.padding } set padding(t) { this._config.padding !== t && (this._config.padding = t, this.refresh()) } attach() { if ("unattached" === this._state && this._e.parentElement) { !function () { if (!window.__rno_kf_s) { let t = window.__rno_kf_s = document.createElement("style"); t.textContent = "@keyframes rough-notation-dash { to { stroke-dashoffset: 0; } }", document.head.appendChild(t) } }(); let t = this._svg = document.createElementNS(e, "svg"); t.setAttribute("class", "rough-annotation"); let s = t.style; s.position = "absolute", s.top = "0", s.left = "0", s.overflow = "visible", s.pointerEvents = "none", s.width = "100px", s.height = "100px"; let i = "highlight" === this._config.type; if (this._e.insertAdjacentElement(i ? "beforebegin" : "afterend", t), this._state = "not-showing", i) { let n = window.getComputedStyle(this._e).position; n && "static" !== n || (this._e.style.position = "relative") } this.attachListeners() } } detachListeners() { window.removeEventListener("resize", this._resizeListener), this._ro && this._ro.unobserve(this._e) } attachListeners() { this.detachListeners(), window.addEventListener("resize", this._resizeListener, { passive: !0 }), !this._ro && "ResizeObserver" in window && (this._ro = new window.ResizeObserver(t => { for (let e of t) e.contentRect && this._resizeListener() })), this._ro && this._ro.observe(this._e) } haveRectsChanged() { if (this._lastSizes.length) { let t = this.rects(); if (t.length !== this._lastSizes.length) return !0; for (let e = 0; e < t.length; e++)if (!this.isSameRect(t[e], this._lastSizes[e])) return !0 } return !1 } isSameRect(t, e) { let s = (t, e) => Math.round(t) === Math.round(e); return s(t.x, e.x) && s(t.y, e.y) && s(t.w, e.w) && s(t.h, e.h) } isShowing() { return "not-showing" !== this._state } refresh() { this.isShowing() && !this.pendingRefresh && (this.pendingRefresh = Promise.resolve().then(() => { this.isShowing() && this.show(), delete this.pendingRefresh })) } show() { switch (this._state) { case "unattached": break; case "showing": this.hide(), this._svg && this.render(this._svg, !0); break; case "not-showing": this.attach(), this._svg && this.render(this._svg, !1) } } hide() { if (this._svg) for (; this._svg.lastChild;)this._svg.removeChild(this._svg.lastChild); this._state = "not-showing" } remove() { this._svg && this._svg.parentElement && this._svg.parentElement.removeChild(this._svg), this._svg = void 0, this._state = "unattached", this.detachListeners() } render(t, e) { let s = this._config; e && ((s = JSON.parse(JSON.stringify(this._config))).animate = !1); let i = this.rects(), n = 0; i.forEach(t => n += t.w); let r = s.animationDuration || 800, o = 0; for (let a = 0; a < i.length; a++) { let h = r * (i[a].w / n); p(t, i[a], s, o + this._animationDelay, h, this._seed), o += h } this._lastSizes = i, this._state = "showing" } rects() { let t = []; if (this._svg) { if (this._config.multiline) { let e = this._e.getClientRects(); for (let s = 0; s < e.length; s++)t.push(this.svgRect(this._svg, e[s])) } else t.push(this.svgRect(this._svg, this._e.getBoundingClientRect())) } return t } svgRect(t, e) { let s = t.getBoundingClientRect(), i = e; return { x: (i.x || i.left) - (s.x || s.left), y: (i.y || i.top) - (s.y || s.top), w: i.width, h: i.height } } } return t.annotate = function (t, e) { return new $(t, e) }, t.annotationGroup = function (t) { let e = 0; for (let s of t) { let i = s; i._animationDelay = e, e += 0 === i.animationDuration ? 0 : i.animationDuration || 800 } let n = [...t]; return { show() { for (let t of n) t.show() }, hide() { for (let t of n) t.hide() } } }, Object.defineProperty(t, "__esModule", { value: !0 }), t }({}); function bricksableTextNotation() { bricksQuerySelectorAll(document, ".brxe-ba-text-notation").forEach(function (t) { t.dataset.scriptId; try { i = JSON.parse(t.querySelector(".ba-text-notation-wrapper").dataset.baBricksTextNotationOptions) } catch (e) { return !1 } var s = i; if (i.hasOwnProperty("type")) { var i, n, r = t.querySelector(".ba-text-notation-inner"), o = RoughNotation.annotate(r, s); if (n = "undefined" == typeof Waypoint ? new BricksIntersect({ element: t, callback: function (t) { window.BricksabletextNotationData.textNotationInstances[i] && o.hide(), window.BricksabletextNotationData.textNotationInstances[i] = o.show() } }) : new Waypoint({ element: t, handler: function () { window.BricksabletextNotationData.textNotationInstances[i] && o.hide(), window.BricksabletextNotationData.textNotationInstances[i] = o.show() }, triggerOnce: !0, offset: "bottom-in-view" }), t.classList.contains("brxe-ba-text-notation")) { let a = t.parentElement, h = t.lastChild, l = { characterData: !0, attributes: !1, childList: !1, subtree: !0 }, c = function (t, e) { for (let s of t) console.log("Bricksable: Text Notation styling was updated."), o.hide(), o.show() }, u = new MutationObserver(c); u.observe(h, l), u.observe(a, l) } } }) } document.addEventListener("DOMContentLoaded", function (t) { bricksIsFrontend && document.fonts.ready.then(function () { bricksableTextNotation() }) });
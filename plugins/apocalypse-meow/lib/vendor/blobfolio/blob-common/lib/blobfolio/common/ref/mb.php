<?php
 namespace blobfolio\wp\meow\vendor\common\ref; use \blobfolio\wp\meow\vendor\common\constants; use \blobfolio\wp\meow\vendor\common\mb as v_mb; class mb { public static function str_pad(&$str, int $pad_length, $pad_string=' ', int $pad_type=\STR_PAD_RIGHT) { cast::string($str, true); cast::string($pad_string, true); $current_length = v_mb::strlen($str); $pad_string_length = v_mb::strlen($pad_string); if ($pad_length <= $current_length || ! $pad_string_length) { return; } if (\STR_PAD_LEFT === $pad_type) { $str = \str_repeat($pad_string, \ceil(($pad_length - $current_length) / $pad_string_length)) . $str; $new_length = v_mb::strlen($str); if ($new_length > $pad_length) { $str = v_mb::substr($str, $new_length - $pad_length, null); } } elseif (\STR_PAD_BOTH === $pad_type) { $leftright = 'right'; while (v_mb::strlen($str) < $pad_length) { $leftright = 'left' === $leftright ? 'right' : 'left'; if ('left' === $leftright) { $str = "{$pad_string}{$str}"; } else { $str .= $pad_string; } } $new_length = v_mb::strlen($str); if ($new_length > $pad_length) { if ('left' === $leftright) { $str = v_mb::substr($str, $new_length - $pad_length, null); } else { $str = v_mb::substr($str, 0, $pad_length); } } } else { $str .= \str_repeat($pad_string, \ceil(($pad_length - $current_length) / $pad_string_length)); $new_length = v_mb::strlen($str); if ($new_length > $pad_length) { $str = v_mb::substr($str, 0, $pad_length); } } } public static function str_split(&$str, int $split_length=1) { if ($split_length < 1) { $str = false; return false; } cast::string($str, true); if (1 === $split_length) { \preg_match_all('/./us', $str, $matches); } else { \preg_match_all("/.{1,$split_length}/us", $str, $matches); } $str = ! empty($matches[0]) ? $matches[0] : array(); return true; } public static function strrev(&$str) { cast::string($str, true); if (! $str) { return false; } \preg_match_all('/./us', $str, $arr); $str = \implode('', \array_reverse($arr[0])); return true; } public static function strtolower(&$str, bool $strict=false) { if (\is_array($str)) { foreach ($str as $k=>$v) { static::strtolower($str[$k], $strict); } } elseif (! $strict || \is_string($str)) { cast::string($str, true); if ($str) { if ( \function_exists('mb_strtolower') && ( ! \function_exists('mb_check_encoding') || ! \mb_check_encoding($str, 'ASCII') ) ) { $str = \mb_strtolower($str, 'UTF-8'); $from = \array_keys(constants::CASE_CHARS); $to = \array_values(constants::CASE_CHARS); $str = \str_replace($from, $to, $str); } else { $str = \strtolower($str); } } } } public static function strtoupper(&$str, bool $strict=false) { if (\is_array($str)) { foreach ($str as $k=>$v) { static::strtoupper($str[$k], $strict); } } elseif (! $strict || \is_string($str)) { cast::string($str, true); if ($str) { if ( \function_exists('mb_strtoupper') && ( ! \function_exists('mb_check_encoding') || ! \mb_check_encoding($str, 'ASCII') ) ) { $str = \mb_strtoupper($str, 'UTF-8'); $to = \array_keys(constants::CASE_CHARS); $from = \array_values(constants::CASE_CHARS); $str = \str_replace($from, $to, $str); } else { $str = \strtoupper($str); } } } } public static function trim(&$str='') { if (\is_array($str)) { foreach ($str as $k=>$v) { static::trim($str[$k]); } } else { cast::string($str, true); $str = \preg_replace('/(^\s+|\s+$)/u', '', $str); } } public static function ucfirst(&$str, bool $strict=false) { if (\is_array($str)) { foreach ($str as $k=>$v) { static::ucfirst($str[$k], $strict); } } elseif (! $strict || \is_string($str)) { cast::string($str, true); if ($str) { if ( \function_exists('mb_substr') && ( ! \function_exists('mb_check_encoding') || ! \mb_check_encoding($str, 'ASCII') ) ) { $first = v_mb::substr($str, 0, 1); static::strtoupper($first, false); $str = $first . v_mb::substr($str, 1, null); } else { $str = \ucfirst($str); } } } } public static function ucwords(&$str, bool $strict=false) { if (\is_array($str)) { foreach ($str as $k=>$v) { static::ucwords($str[$k], $strict); } } elseif (! $strict || \is_string($str)) { cast::string($str, true); if ($str) { $str = \preg_replace_callback('/^(\p{L})/u', function($matches) { static::strtoupper($matches[0]); return $matches[0]; }, $str); $str = \preg_replace_callback('/(\s|\p{Pd}|\/)(.)/u', function($matches) { static::strtoupper($matches[2], false); return $matches[1] . $matches[2]; }, $str); } } } public static function wordwrap(&$str, int $width=75, $break="\n", bool $cut=false) { cast::string($str, true); cast::string($break, true); if (! $str || $width <= 0) { return; } if (! \function_exists('mb_substr')) { $str = \wordwrap($str, $width, $break, $cut); return; } $chunks = \preg_split('/([\s$]+)/uS', \trim($str), -1, \PREG_SPLIT_DELIM_CAPTURE); $lines = array(''); $line = 0; foreach ($chunks as $v) { if (\preg_match('/\v/u', $v)) { $line++; $lines[$line] = $v; $line++; $lines[$line] = ''; continue; } if (\preg_match('/\h/u', $v)) { $lines[$line] .= $v; continue; } $line_length = v_mb::strlen($lines[$line]); if ($line_length >= $width) { $line++; $lines[$line] = ''; $line_length = 0; } $word_length = v_mb::strlen($v); if ($word_length + $line_length <= $width) { $lines[$line] .= $v; continue; } if ($cut) { static::str_split($v, $width); $v = \implode("\n", $v); } $v = \preg_replace( array( '/(\p{Pd})\n/u', '/(\p{Pd}+)/u', '/(^\s+|\s+$)/u', ), array( '$1', "$1\n", '', ), $v ); $v = \explode("\n", $v); foreach ($v as $v2) { $word_length = v_mb::strlen($v2); $line_length = v_mb::strlen($lines[$line]); if ($word_length + $line_length > $width) { $line++; $lines[$line] = ''; } $lines[$line] .= $v2; } } foreach ($lines as $k=>$v) { if (\preg_match('/\v/u', $v)) { if ($v === $break) { unset($lines[$k]); } $lines[$k] = \preg_replace( '/^' . \preg_quote($break, '/') . '/ui', '', $v ); continue; } static::trim($lines[$k]); } $str = \implode($break, $lines); static::trim($str); } } 
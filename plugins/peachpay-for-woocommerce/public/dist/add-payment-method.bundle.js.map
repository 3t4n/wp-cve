{"version":3,"file":"add-payment-method.bundle.js","mappings":"8fAEA,SAASA,IACR,IAAMC,ECQP,SAAoCC,EAAkBC,QAAA,IAAAA,IAAAA,EAAA,MACrD,IAAMC,EAAWC,SAASC,cAAiBJ,GAK3C,OAJIE,GAAmB,OAAPD,GACfA,EAAGC,GAGGA,CACR,CDf2BG,CAAsB,yDAE3CN,GAILA,EAAkBO,iBAAiB,MAAMC,SAAQ,SAAAC,GAC5CA,EAAIC,UAAUC,SAAS,cAAgBF,EAAIC,UAAUC,SAAS,wCACjEF,EAAIG,QAEN,GACD,CAEAR,SAASS,iBAAiB,oBAAoB,WAC7Cd,GACD,G","sources":["webpack://peachpay-for-woocommerce/./frontend/storefront/ts/account-payment-methods.ts","webpack://peachpay-for-woocommerce/./frontend/@shared/ts/dom.ts"],"sourcesContent":["import {$qs} from '../../@shared/ts/dom';\n\nfunction hidePeachPayPaymentMethods() {\n\tconst paymentMethodList = $qs<HTMLUListElement>('ul.woocommerce-PaymentMethods.payment_methods.methods');\n\n\tif (!paymentMethodList) {\n\t\treturn;\n\t}\n\n\tpaymentMethodList.querySelectorAll('li').forEach($el => {\n\t\tif ($el.className.includes('peachpay') && !$el.className.includes('payment_method_peachpay_stripe_card')) {\n\t\t\t$el.remove();\n\t\t}\n\t});\n}\n\ndocument.addEventListener('DOMContentLoaded', () => {\n\thidePeachPayPaymentMethods();\n});\n","import {getErrorString} from './error';\nimport {type IWindowFetchMessage, type IWindowMessage} from '../../@type/window-messages';\nimport {captureSentryException} from './sentry';\n\n/**\n * Resulting helper function to comply with typescript by\n * always checking the result of $qs\n *\n * @param { string } \t\tselector html query selector string\n * @param { (T) => void } \tcb callback function that will only be called if the element is found\n */\nfunction $qs<T extends HTMLElement>(selector: string, cb: null | (($element: T) => void) = null): T | null {\n\tconst $element = document.querySelector<T>(selector);\n\tif ($element && cb !== null) {\n\t\tcb($element);\n\t}\n\n\treturn $element;\n}\n\n/**\n * Helper function for \"document.querySelectorAll\" that always returns a proper array\n * and has the base type \"HTMLElement\" instead of the almost never used \"Element\".\n */\nfunction $qsAll<T extends HTMLElement>(selector: string, callback?: ($element: T) => void): T[] {\n\tconst result = Array.from(document.querySelectorAll<T>(selector));\n\n\tif (callback) {\n\t\tfor (const $element of result) {\n\t\t\tcallback($element);\n\t\t}\n\t}\n\n\treturn result;\n}\n\n/**\n * Loads a given JS script.\n *\n * @param src URL of the script\n * @param scriptWindowObject Name of the object the script defines if the script defines any objects\n */\nasync function loadScript(src: string, scriptWindowObject: string | null, callback?: () => void): Promise<void> {\n\treturn new Promise((resolve, reject) => {\n\t\tif (document.querySelector(`script[src=\"${src}\"]`) ?? (window as any)[scriptWindowObject ?? '']) {\n\t\t\tcallback?.();\n\t\t\tresolve();\n\t\t}\n\n\t\tconst $script = document.createElement('script');\n\t\t$script.type = 'text/javascript';\n\t\t$script.src = src;\n\n\t\t($script as any).onreadystatechange = () => {\n\t\t\tcallback?.();\n\t\t\tresolve();\n\t\t};\n\n\t\t$script.onload = () => {\n\t\t\tcallback?.();\n\t\t\tresolve();\n\t\t};\n\n\t\t$script.onerror = reject;\n\n\t\tdocument.head.appendChild($script);\n\t});\n}\n\ninterface WindowFetchData<T> {\n\terror: Error;\n\tresult: T;\n}\n\nasync function fetchWindowData<TRequest, TResponse>(targetWindow: Window | null, endpoint: string, request?: TRequest): Promise<TResponse> {\n\treturn new Promise((resolve, reject) => {\n\t\tconst channel = new MessageChannel();\n\t\tchannel.port1.onmessage = ({data}) => {\n\t\t\tchannel.port1.close();\n\n\t\t\tif ((data as WindowFetchData<TResponse>).error) {\n\t\t\t\treject((data as WindowFetchData<TResponse>).error);\n\t\t\t} else {\n\t\t\t\tresolve((data as WindowFetchData<TResponse>).result);\n\t\t\t}\n\t\t};\n\n\t\tif (targetWindow) {\n\t\t\ttargetWindow.postMessage(\n\t\t\t\t{\n\t\t\t\t\tevent: endpoint,\n\t\t\t\t\trequest,\n\t\t\t\t},\n\t\t\t\tlocation.origin,\n\t\t\t\t[channel.port2],\n\t\t\t);\n\t\t} else {\n\t\t\treject(new Error('Target window is not valid.'));\n\t\t}\n\t});\n}\n\n/**\n * Allows for async request from the host page for data.\n */\nfunction onWindowDataFetch<TRequest, TResponse>(endpoint: string, requestCallback: (request: TRequest) => Promise<TResponse> | TResponse): void {\n\twindow.addEventListener('message', async (message: MessageEvent<IWindowFetchMessage<TRequest>>) => {\n\t\tif (message.origin !== location.origin) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (message.data.event === endpoint) {\n\t\t\ttry {\n\t\t\t\tconst response = await requestCallback(message.data.request as unknown as TRequest);\n\n\t\t\t\tmessage.ports?.[0]?.postMessage({result: response});\n\t\t\t} catch (error: unknown) {\n\t\t\t\ttry {\n\t\t\t\t\tmessage.ports?.[0]?.postMessage({error});\n\t\t\t\t} catch (secondaryError: unknown) {\n\t\t\t\t\tmessage.ports?.[0]?.postMessage({error: new Error(getErrorString(error))});\n\t\t\t\t\tcaptureSentryException(secondaryError as Error, {\n\t\t\t\t\t\toriginalError: error,\n\t\t\t\t\t\toriginalErrorString: getErrorString(error),\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t});\n}\n\nasync function fetchHostWindowData<TRequest, TResponse>(endpoint: string, request?: TRequest): Promise<TResponse> {\n\treturn fetchWindowData(window.top, endpoint, request);\n}\n\n/**\n * Helper function to give strong typing to a Message Event\n */\nfunction onWindowMessage<T extends IWindowMessage>(eventName: string, cb: (event: T) => void | Promise<void>) {\n\twindow.addEventListener('message', async (event: MessageEvent<T>) => {\n\t\tif (event.origin !== location.origin) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (event.data.event === eventName) {\n\t\t\tawait cb(event.data);\n\t\t}\n\t}, false);\n}\n\n// https://ourcodeworld.com/articles/read/376/how-to-strip-html-from-a-string-extract-only-text-content-in-javascript\nfunction stripHtml(html: string, preFilterSelector: string | null = 'a'): string {\n\tconst temporalDivElement = document.createElement('div');\n\ttemporalDivElement.innerHTML = html;\n\n\tif (preFilterSelector) {\n\t\ttemporalDivElement.querySelectorAll(preFilterSelector).forEach($el => {\n\t\t\t$el.remove();\n\t\t});\n\t}\n\n\t// eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing\n\treturn (temporalDivElement.textContent || temporalDivElement.innerText || '').trim();\n}\n\nfunction isMobile() {\n\treturn window.innerWidth < 900;\n}\n\nexport {\n\t$qs,\n\t$qsAll,\n\tstripHtml,\n\tloadScript,\n\tfetchHostWindowData,\n\tonWindowMessage,\n\tonWindowDataFetch,\n\tisMobile,\n};\n"],"names":["hidePeachPayPaymentMethods","paymentMethodList","selector","cb","$element","document","querySelector","$qs","querySelectorAll","forEach","$el","className","includes","remove","addEventListener"],"sourceRoot":""}